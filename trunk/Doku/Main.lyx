#LyX 1.6.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\language ngerman
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Beschleunigung von AES-Verschlüsselungen unter Zuhilfenahme einer GPU
\end_layout

\begin_layout Author
Simon Waloschek, Benedikt Krüger, Ibrahim Alptekin, Daniel Nickchen
\end_layout

\begin_layout Subject
Projektarbeit des Studienganges 
\begin_inset Quotes eld
\end_inset

Ingenieurinformatik
\begin_inset Quotes erd
\end_inset

 im Rahmen des Softwarepraktikums
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einführung und Grundlagen
\end_layout

\begin_layout Subsection
Einleitung
\end_layout

\begin_layout Standard
Moderne Verschlüsselungsalgorithmen sind im Allgemeinen sehr rechenintensiv
 und werden oft als Bestandteil des Betriebssystems ausgeführt.
 Da gewöhnliche CPUs für diese Art von Operationen nicht ausgelegt sind,
 wird das gesamte System durch die entstehende Auslastung gebremst.
 Es liegt also nahe, eine geeignetere Plattform für die Berechnung von Verschlüs
selungen zu nutzen.
\end_layout

\begin_layout Standard
Im Rahmen dieses Praktikums wird daher evaluiert, inwiefern sich moderne
 Grafikkarten bzw.
 FPGAs zur optimierteren Ausführung nutzen lassen.
 Die Verschlüsselungen sollen transparent in den Linux-Kernel eingebunden
 und systemweit zur Verfügung gestellt werden.
\end_layout

\begin_layout Standard
Im Folgenden wird mithilfe des CUDA-Frameworks von NVIDIA der AES-Algorithmus
 auf einer GPU vom Typ 
\begin_inset Quotes eld
\end_inset

8800 GTS
\begin_inset Quotes erd
\end_inset

 aus dem Hause NVIDIA implementiert und durch eine Reihe von Tests auf eine
 eventuelle Verbesserung der Datendurchsatzrate hin überprüft.
\end_layout

\begin_layout Subsection
Grundlagen
\end_layout

\begin_layout Subsubsection
AES im Kurzüberblick
\end_layout

\begin_layout Standard
Der Advanced Encryption Standard (AES) ist ein symmetrisches Kryptosystem.
 Es wurde von Joan Daemen und Vincent Rijmen im Rahmen eines international
 ausgeschriebenen Wettbewerbes des National Institute of Standards and Technolog
y (NIST) entwickelt.
 Als Nachfolger von DES und 3DES, gilt AES seit 2000 als De-facto Verschlüsselun
gsstandard, welcher Dank seiner starken Verschlüsselung selbst höchsten
 Sicherheitsansprüchen genügt.
\end_layout

\begin_layout Standard
Bei AES handelt es sich um ein Blockverschlüsselungssystem, auch Blockchiffre
 genannt, also ein Verschlüsselungsverfahren, bei dem der Klartext in eine
 Folge gleichgroßer Blöcke zerlegt wird.
 Diese Blöcke werden anschließend unabhängig voneinander mit einem aus einem
 Schlüsselwort berechneten Blockschlüssel chiffriert.
 Somit werden auch Chiffretextblöcke mit einer festen Länge erzeugt und
 letzendlich zum endgültigen Chiffretext aneinandergereiht.
 
\end_layout

\begin_layout Standard
AES schränkt die Blocklänge auf 128 Bit ein.
 Die Schlüssellänge kann jedoch zwischen 128, 192 und 256 Bit gewählt werden,
 weshalb zwischen den drei AES-Varianten AES-128, AES-192 und AES-256 unterschie
den wird.
 AES bietet ein sehr hohes Maß an Sicherheit und ist in den USA sogar für
 staatliche Dokumente mit höchster Geheimhaltungsstufe zugelassen.
 Der Algorithmus ist frei verfügbar und darf ohne Lizenzgebühren eingesetzt
 sowie in Software bzw.
 Hardware implementiert werden.
\end_layout

\begin_layout Subsubsection
CUDA Framework
\end_layout

\begin_layout Standard
Das „Compute Unified Device Architecture Software Developer Kit“ (CUDA SDK)
 wurde von NVIDA am 15.
 Februar 2007 erstmals der Öffentlichkeit vorgestellt.
 Intention dieses SDKs ist, die Programmierung aktueller Grafikkarten unter
 einer einheitlichen und standardisierten Schnittstelle zu ermöglichen.
\end_layout

\begin_layout Standard
Die Architektur moderner GPUs ist aufgrund ihrer Geschichte als reine Berechnung
seinheit für Bildschirmausgaben für den Zweck ausgelegt, Operationen parallel
 auszuführen.
 Als Co-Prozessor können GPUs somit Dank der CUDA-API dazu genutzt werden,
 bestimmte Programmteile signifikat schneller abzuarbeiten.
\end_layout

\begin_layout Standard
CUDA basiert auf einer optimierten Variante von C (
\begin_inset Quotes eld
\end_inset

C for CUDA
\begin_inset Quotes erd
\end_inset

) und ist damit weitestgehend plattformunabhängig.
 So ist es möglich, entsprechend programmierte CUDA-Anwendungen unter Windows,
 Linux und Mac OS auszuführen - eine kompatible Grafikkarte vorausgesetzt.
\end_layout

\begin_layout Section
GPU Architektur
\end_layout

\begin_layout Standard
Moderne Grafikkarten bestehen aus einer speziellen Architektur, welche es
 erlaubt, viele Rechenoperationen parallel auszuführen.
 Je nach Grafikkarte und Hersteller ist die Architektur jedoch verschieden.
 Im Folgenden wird auf die Architektur der „GeForce 8800 GTS“ von NVIDIA
 eingegangen, da diese verwendet wurde.
\end_layout

\begin_layout Subsection
Begriffsklärung
\end_layout

\begin_layout Standard
Um den Aufbau der Architektur und des Programmes besser verstehen zu können,
 wird an dieser Stelle auf einige Begrifflichkeiten eingegangen.
\end_layout

\begin_layout Standard
So bald ein CUDA-Programmfluss angestoßen wird, wird ein sogenanntes Grid
 erstellt, welches mehrere Threads enthält, welche wiederum alle die gleiche
 Kernel-Funktion ausführen.
\end_layout

\begin_layout Standard
Unter einer 
\begin_inset Quotes eld
\end_inset

Kernel-Funktion
\begin_inset Quotes erd
\end_inset

 wird die Funktion verstanden, welche parallel auf der Grafikarte ausgeführt
 werden soll, in diesem Fall sind dies AES_decrypt und AES_encrypt.
 Da alle Kernel-Funktionen den gleichen Code ausführen, benötigen sie feste
 und einzigartige Variablen, über die sich die Kernel-Funktionen identifizieren
 können - schließlich soll jede Kernel-Funktion etwas Anderes und ihr Zugewiesen
es berechnen.
\end_layout

\begin_layout Standard
Hierzu werden die Threads in einer zweistufigen Hierarchie angeordnet.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Grid_Block.emf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Thread-Hierachie
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf der untersten Stufe werden die Threads in Blöcken angeordnet.
 Die Variablen über welche sich die Threads identifizieren können sind blockId
 und threadId – Also die Nummer des Blockes und Position des Threads.
 Diese werden zur Laufzeit des Threads von der CUDA-runtime angelegt.
 Die Threads eines Blockes werden ein einer dreidimensionalen Struktur angelegt.
 So besteht jede threadId aus 3 Koordinaten: x, y und z.
 Wie viele Threads in jeder Richtung angelegt werden, wird bei dem sogenannten
 „Kernen-Launch“ bestimmt, hierzu später mehr.
 Es können jedoch maximal 512 Threads einem Block zugewiesen werden.
 Wie sie in dem Block angelegt werden (z.B.
 512x1x1, 16x16x2 oder 8x16x2) ist dem Entwickler überlassen.
 Da die Threads in einer dreidimensionalen Struktur abgelegt werden, ist
 auch threadId eine Struktur, die diese 3 Koordinaten hält.
 Es kann also zum Beispiel die genaue Position des Threads abgefragt werden,
 indem threadId.x, threadId.y und threadId.z ausgewertet werden.
\end_layout

\begin_layout Standard
Auf der oberen Stufe der Hierarchie werden die Blöcke zu einem Grid zusammengefa
sst.
 werden die Blöcke in einem zweidimensionalen Koordinatensystem abgelegt.
 Der Programmierer kann bei dem Aufruf der Kernel-Funktion in Cuda bestimmen,
 wie viele Blöcke in x- und y-Richtung angelegt werden sollen.
 Hierbei ist zu beachten, dass die Dimensionen des Grids einmalig angelegt
 werden - bei „Kernel-Launch“.
 Später kann hierauf kein Einfluss mehr genommen werden! Auch die blockId
 muss also eine zweidimensionale Struktur beinhalten: blockId.x und blockId.y.
\end_layout

\begin_layout Subsection
Der Kernel-Launch
\end_layout

\begin_layout Standard
Der Kernel-Launch bestimmt, in welchen Dimensionen die Blöcke und das Grid
 angelegt werden sollen.
 Damit wird auch bestimmt, wie viele Threads insgesamt ausgeführt werden
 sollen.
\end_layout

\begin_layout Standard
Zunächst wird bestimmt, wie die Dimensionen der Blöcke aussehen sollen:
\end_layout

\begin_layout Standard
dim3 dimBlock(2,2,2);
\end_layout

\begin_layout Standard
Anschließend werden die Dimensionen des Grids festgelegt:
\end_layout

\begin_layout Standard
dim3 dimGrid(2,3,1);
\end_layout

\begin_layout Standard
Bei den Dimensionen des Grids werden lediglich die x- und y-Dimensionen
 berücksichtigt, da die Grid-Struktur nur zweidimensional ist.
 So ist es üblich, als dritte Variable den Wert 1 zu setzen, es ist jedoch
 ein beliebiger Wert möglich!
\end_layout

\begin_layout Standard
Zum Schluss wird der eigentliche Kernel-Launch ausgeführt, gegebenenfalls
 mit einer Liste an Parametern:
\end_layout

\begin_layout Standard
KernelFunktion<<<dimGrid, dimBlock>>>( PARAMETERLISTE); 
\end_layout

\begin_layout Subsection
Die Architektur der GeForce 8800 GTS
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/8800GTS.jpg
	width 70text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
8800GTS-Architektur
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie oben dargestellt, besteht die „GeForce 8800 GTS“ aus 16 Multiprozessoren
 (MP).
 Jeder der MPs hat einen eigenen Speicher, den sog.
 „Shared Memory“ (16384 bytes pro MP), sowie eigene Register (8192 pro MP)
 und 8 Streamingprozessoren (SP).
 Die SPs führen jeweils genau einen Thread aus.
 Die Eingabedaten werden aus dem L1-Cache geladen und die Ergebnisse der
 Berechnungen der SPs werden dort wieder abgelegt.
\end_layout

\begin_layout Subsection
Speicherhierarchie
\end_layout

\begin_layout Standard
Der Speicher, auf den sowohl Grafikkarte als auch CPU Zugriff haben, ist
 der 
\shape italic
RAM
\shape default
 („Global Memory“).
 Dieser ist für gewöhnlich am größten und jedoch auch am langsamsten.
\end_layout

\begin_layout Standard
Von diesem Speicher werden die Daten im Verlauf des Programmes in den 
\shape italic
Shared Memory
\shape default
 geladen.
 Dieser befindet sich auf der Grafikkarte und ist auch nur von dieser anzusprech
en.
 Jeder MP hat die gleiche Größe des Shares Memory: 16 KB.
 Dieser wird auf die SPs des MPs aufgeteilt.
\end_layout

\begin_layout Standard
Zusätzlich gibt es noch einen Speicher für Konstanten des Programmes, den
 sog.

\shape italic
 Constant Memory
\shape default
.
 Dieser ist physikalisch auf 64 KB beschränkt und für alle SPs des MPs zugänglic
h! Für die Berechnungen hat jeder SP darüber hinaus 
\shape italic
Register
\shape default
, welche die schnellsten Zugriffszeiten aufweisen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/Speicherpyramiede.emf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Speicherhierarchie Grafikkarte
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei der Speicherhierarchie ist zu beachten, dass die beiden wichtigsten
 Ebenen (RAM und Shared Memory) physikalisch getrennt liegen.
 So liegt der RAM auf dem Mainboard und ist für CPU und Grafikkarte ansprechbar.
 Der Shared Memory ist nur von der Grafikkarte ansprechbar.
 So sind die Ergebnisse der Berechnungen von dem Shared Memory explizit
 auf den RAM zu kopieren!
\end_layout

\begin_layout Subsection
Ausführung
\end_layout

\begin_layout Standard
Jeder MP bekommt einen Warp zugewiesen.
 Bei der verwendeten „GeForce 8800 GTS“ entspricht ein Warp einer Ansammlung
 von 32 Threads.
 Die Threads bestehen pro Ausführung in dem Warp immer aus dem gleichen
 Quellcode.
 Sie bekommen jedoch intern IDs zugewiesen, über welche sie sich identifizieren
 und - entsprechend ihrem Programmfluss - beeinflussen können.
 Der Thread wird gemeinsam mit den Eingabedaten auf die Grafikkarte kopiert,
 wobei die Eingabedaten in den Shared Memory abgelegt werden.
 Anschließend beginnen die SPs mit der Bearbeitung der Daten.
 Wenn alle Threads berechnet wurden - also im Normalfall jeder SP 2 Threads
 bearbeitet hat - werden die Ergebnisse aus dem Shared Memory zurück in
 den RAM kopiert und von dort über die CPU weiterverwendet.
 Im Anschluss ist der MP bereit für den nächsten Warp und das Ganze beginnt
 wieder von vorne.
 
\end_layout

\begin_layout Section
AES-Implementierung
\end_layout

\begin_layout Subsection
Algorithmus im Detail
\end_layout

\begin_layout Standard
Im diesem Kapitel wird der Ablauf des AES Algorithmus vorgestellt.
 Er besteht aus mehreren Phasen, auf die im Folgenden genauer eingegangen
 wird.
 Anzumerken sei, dass bei Beispielen der Einfachheit halber von einer 128
 Bit-Verschlüsselung ausgegangen wird.
\end_layout

\begin_layout Standard
Jeder Block wird zunächst in eine zweidimensionale Tabelle mit vier Zeilen
 und vier Spalten geschrieben, deren Zellen ein Byte groß sind.
 Jeder Block wird nun nacheinander bestimmten Transformationen unterzogen.
 Anstatt jeden Block einmal mit dem Schlüssel zu verschlüsseln, wendet AES
 verschiedene Teile des erweiterten Originalschlüssels nacheinander auf
 den Klartext-Block an.
 Die Anzahl r dieser Runden variiert und ist von der Schlüssellänge k abhängig:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Schlüssellänge k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runden r
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Rundenlängen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Ablauf jeder einzelnen Block-Verschlüsselung entspricht folgendem Schema:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/EncryptionProcess.eps
	height 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablaufschema
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Schlüsselexpansion
\end_layout

\begin_layout Standard
Vor der ersten Chiffrierung muss zunächst einmal der Schlüssel entsprechend
 aufbereitet werden.
\end_layout

\begin_layout Standard
Der Benutzerschlüssel muss in r+1 Teilschlüssel aufgeteilt werden, die sogenannt
en Rundenschlüssel.
 Diese müssen dieselbe Länge wie die Blöcke haben, was bedeutet, dass der
 Benutzerschlüssel zunächst auf die Länge k*(r+1) expandiert werden muss.
 Aus diesem werden die Rundenschlüssel erzeugt und ebenfalls in Tabellen
 (Arrays) mit vier Spalten und vier Zeilen gespeichert.
 Für die Erzeugung der ersten Spalte des jeweils nächsten Rundenschlüssels
 wird zunächst die letzte Spalte des vorherigen Schlüssels, am Anfang also
 des Benutzerschlüssels, genommen und um eine Zeile nach oben rotiert.
 Die oberste Zelle wird unten wieder eingefügt.
 Nun erfolgt eine Substitution der vier Werte mit Hilfe der sogenannten
 Substitutionsbox.
 Sie ist meist als Array aufgebaut und gibt an, wie jedes Byte durch einen
 anderen Wert zu ersetzen ist.
 
\end_layout

\begin_layout Standard
Die Konstruktion der S-Box unterliegt Designkriterien, die die Anfälligkeit
 für die Methoden der linearen und der differentiellen Kryptoanalyse sowie
 für algebraische Attacken minimieren sollen.
 Mit Hilfe der S-Box wird jedes Byte des Blocks durch ein Äquivalent ersetzt
 und die Daten somit monoalphabetisch verschlüsselt.
 Diese neuerzeugte Spalte wird mit der drei Spalten zurückliegenden Spalte
 und mit der ersten Spalte der sogenannten Rcon-Tabelle XOR-verknüpft.
 
\end_layout

\begin_layout Standard
Die Rcon-Tabelle ist ebenfalls in Form eines Arrays mit 4 Zeilen und einer
 Spalte für jeden Rundenschlüssel aufgebaut.
 Sie enthält konstante Werte, die auf einem mathematischen System beruhen.
 Die aus der XOR-Verknüpfung erzeugten Werte ergeben die erste Spalte des
 nächsten Rundenschlüssels.
 Die restlichen drei Spalten ergeben sich jeweils aus einer XOR-Verknüpfung
 der davor liegenden und der zu dieser drei zurückliegenden Spalte.
 Für alle folgenden Rundenschlüssel läuft die Berechnung analog ab.
\end_layout

\begin_layout Subsubsection
Vorrunde
\end_layout

\begin_layout Standard
Bei AddRoundKey erfolgt eine XOR-Verknüpfung zwischen dem zu verschlüsselnden
 Block und dem ersten Rundenschlüssel (siehe Abb.4).
 Nur an dieser Stelle ist der Algorithmus vom Benutzerschlüssel abhängig.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/addroundkey.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AddRoundKey
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verschlüsselungsrunden
\end_layout

\begin_layout Standard
In den folgenden Verschlüsselungsrunden wird zunächst eine Substitution
 mittels der erwähnten S-Box durchgeführt.
 
\end_layout

\begin_layout Standard
Im darauffolgenden Schritt, genannt ShiftRow, werden die Zeilen um eine
 bestimmte Anzahl von Spalten nach links verschoben und links hinausgeschobene
 Zellen rechts wieder angefügt.
 Die erste Zeile bleibt konstant, die zweite wird um eine, die dritte um
 zwei und die vierte um drei Spalten verschoben.
 Abbildung 5 veranschaulicht dieses Vorgehen.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/shiftrow.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ShiftRow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im MixColumn-Schritt wird zunächst jede Zelle mit einer Konstanten multipliziert
 und dann die Spalten mit den Ergebnissen der Multiplikation XOR verknüpft.
 Durch eine geschickte Analyse dieser Operation, vereinfacht sich die Rechnung
 zu einer simplen Matrizenmultiplikation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/mixcolumn.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MixColumn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum Ende jeder Verschlüsselungsrunde wird noch einmal AddRoundKey ausgeführt.
 Abgeschlossen wird die Verschlüsselung mit der Schlussrunde, sie verläuft
 identisch zu den übrigen Verschlüsselungsrunden mit dem Unterschied, dass
 keine MixColumn-Funktion ausgeführt wird.
\end_layout

\begin_layout Subsubsection
Entschlüsselung
\end_layout

\begin_layout Standard
Bei der Entschlüsselung von Daten wird entsprechend rückwärts vorgegangen.
 Die Daten werden zunächst wieder in zweidimensionale Tabellen gelesen und
 die Rundenschlüssel generiert.
 Allerdings wird nun mit der Schlussrunde angefangen und alle Funktionen
 in jeder Runde in der umgekehrten Reihenfolge aufgerufen.
 Durch die vielen (symmetrischen) XOR-Verknüpfungen unterscheiden sich die
 meisten Funktionen zum Entschlüsseln nicht von denen zum Verschlüsseln.
 Jedoch muss eine andere S-Box genutzt werden (die sich aus der originalen
 S-Box berechnen lässt) und die Zeilenverschiebungen erfolgen in die andere
 Richtung.
\end_layout

\begin_layout Subsection
C++ Implementierung
\end_layout

\begin_layout Standard
Ausgangspunkt der weiteren Bearbeitung ist eine unfertige C++ Implementierung
 des Algorithmus von Paulo S.
 L.
 M.
 Barreto
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verweis!!!
\end_layout

\end_inset

.
 Der Autor hat bereits erste Ansätze zur Datenverschlüsselung auf einer
 GPU programmiert, hat das Projekt jedoch aus unbekannten Gründen eingestellt,
 sodass noch einige Ergänzungen und Änderungen vorgenommen werden müssen.
\end_layout

\begin_layout Standard
Die Implementierung ist Dank der Ausnutzung komplexerer Galois-Feld-Operationen
 vergleichsweise schnell.
 Hierbei werden die Berechnungen durch Nutzung vorkalkulierter Tabellen
 auf Kosten der Speichereffizienz beschleunigt.
 Der Aufwand der Verschlüsselung verringert sich somit auf eine Reihe (schneller
) Binäroperationen, welche sich auf der GPU vorteilhaft parallel ausführen
 lassen können.
\end_layout

\begin_layout Standard
Zusätzlich ist anzumerken, dass zugunsten der Parallelität der sogenannte
 
\begin_inset Quotes eld
\end_inset

Electronic Code Book Mode
\begin_inset Quotes erd
\end_inset

 (ECB) verwendet wird, also jeder Block mit dem gleichen expandierten Schlüssel
 chiffriert wird.
\end_layout

\begin_layout Subsubsection
Schnittstelle zur Außenwelt
\end_layout

\begin_layout Standard
Um von außen auf die Verschlüsselungsfunktionen zugreifen zu können, enthält
 die genutzte AES-Klasse neben dem Konstruktur 
\begin_inset Quotes eld
\end_inset

öffentliche
\begin_inset Quotes erd
\end_inset

 Funktionen für die Schlüsselexpansionen sowie für die Ver- bzw.
 Entschlüsselung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/class.eps
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Klassendiagramm mit public Funktionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CUDA-spezifische Veränderungen
\end_layout

\begin_layout Subsubsection
Prozessaufteilung
\end_layout

\begin_layout Standard
Zur bestmöglichen Ausnutzung der parallelen Verarbeitungsmöglichkeiten der
 GPU, sollte die Arbeitslast auf möglichst viele Threads aufgeteilt werden.
 Zu diesem Zweck werden zur Laufzeit die (hardwarespezifischen) Eigenschaften
 der GPU ausgewertet und die Programmausführung auf die maximal mögliche
 Anzahl an Blöcken verteilt, in denen schließlich alle verfügbaren Threads
 genutzt werden.
\end_layout

\begin_layout Subsubsection
Speichernutzung
\end_layout

\begin_layout Section
Tests und Benchmarks
\end_layout

\begin_layout Subsection
Testumgebung
\end_layout

\begin_layout Standard
Zur Evaluierung der Korrektheit der entwickelten Lösung, werden zunächst
 vom NIST vorgegebene Klartext-Chiffre-Paare inklusive des passenden Schlüssels
 verwendet.
 Diese Paare umfassen verschiedene Verschlüsselungsstärken und Textlängen
 und eignen sich daher für einen aussagekräftigen Praxistest.
\end_layout

\begin_layout Standard
Um die Performance zu beurteilen und relevante Laufzeitanalysen durchzuführen,
 bietet NVIDIA als Teil des CUDA-SDKs den sogenannten 
\begin_inset Quotes eld
\end_inset

CUDA Profiler
\begin_inset Quotes erd
\end_inset

.
 Dieses grafische Tool erlaubt einen detaillierten Einblick in die Laufzeiten
 einzelner CUDA-Befehle und eignet sich somit zur Bewertung derer Geschwindigkei
t.
 Auch können damit eventuelle 
\begin_inset Quotes eld
\end_inset

Flaschenhälse
\begin_inset Quotes erd
\end_inset

 im Code aufgespürt und ggf.
 korrigiert werden.
\end_layout

\begin_layout Standard
Da die folgenden Tests möglichst unabhängig von der restlichen Hardware
 des Testcomputers sein sollten, wird unter Linux eine RAM-Disk mit verschieden
 großen (zufälligen) Binärdateien erstellt, um den Einfluss der Festplattenlese-
 und -schreibgeschwindigkeit zu minimieren.
 Diese Dateien werden dann unter Einbeziehung des CUDA Profilers vollständig
 ver- bzw.
 entschlüsselt.
\end_layout

\begin_layout Subsection
Ergebnisse
\end_layout

\begin_layout Section
Resumée
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
