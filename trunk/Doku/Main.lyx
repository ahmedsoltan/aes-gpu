#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\language ngerman
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Beschleunigung von AES-Verschlüsselungen unter Zuhilfenahme einer GPU
\end_layout

\begin_layout Author
Simon Waloschek, Benedikt Krüger, Ibrahim Alptekin, Daniel Nickchen
\end_layout

\begin_layout Subject
Projektarbeit des Studienganges 
\begin_inset Quotes eld
\end_inset

Ingenieurinformatik
\begin_inset Quotes erd
\end_inset

 im Rahmen des Softwarepraktikums
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einführung und Grundlagen
\end_layout

\begin_layout Subsection
Einleitung
\end_layout

\begin_layout Standard
Moderne Verschlüsselungsalgorithmen sind im Allgemeinen sehr rechenintensiv
 und werden oft als Bestandteil des Betriebssystems ausgeführt.
 Da gewöhnliche CPUs für diese Art von Operationen nicht ausgelegt sind,
 wird das gesamte System durch die entstehende Auslastung gebremst.
 Es liegt also nahe, eine geeignetere Plattform für die Berechnung von Verschlüs
selungen zu nutzen.
\end_layout

\begin_layout Standard
Im Rahmen dieses Praktikums wird daher evaluiert, inwiefern sich moderne
 Grafikkarten bzw.
 FPGAs zur optimierteren Ausführung nutzen lassen.
 Die Verschlüsselungen sollen transparent in den Linux-Kernel eingebunden
 und systemweit zur Verfügung gestellt werden.
\end_layout

\begin_layout Standard
Im Folgenden wird mithilfe des CUDA-Frameworks von NVIDIA der AES-Algorithmus
 auf einer GPU vom Typ 
\begin_inset Quotes eld
\end_inset

GTS 8800
\begin_inset Quotes erd
\end_inset

 aus dem Hause NVIDIA implementiert und durch eine Reihe von Tests auf eine
 eventuelle Verbesserung der Datendurchsatzrate hin überprüft.
\end_layout

\begin_layout Subsection
Grundlagen
\end_layout

\begin_layout Subsubsection
AES im Kurzüberblick
\end_layout

\begin_layout Standard
Der Advanced Encryption Standard (AES) ist ein symmetrisches Kryptosystem.
 Es wurde von Joan Daemen und Vincent Rijmen im Rahmen eines international
 ausgeschriebenen Wettbewerbes des National Institute of Standards and Technolog
y (NIST) entwickelt.
 Als Nachfolger von DES und 3DES, gilt AES seit 2000 als De-facto Verschlüsselun
gsstandard, welcher Dank seiner starken Verschlüsselung selbst höchsten
 Sicherheitsansprüchen genügt.
\end_layout

\begin_layout Standard
Bei AES handelt es sich um ein Blockverschlüsselungssystem, auch Blockchiffre
 genannt, also ein Verschlüsselungsverfahren, bei dem der Klartext in eine
 Folge gleichgroßer Blöcke zerlegt wird.
 Diese Blöcke werden anschließend unabhängig voneinander mit einem aus einem
 Schlüsselwort berechneten Blockschlüssel chiffriert.
 Somit werden auch Chiffretextblöcke mit einer festen Länge erzeugt und
 letzendlich zum endgültigen Chiffretext aneinandergereiht.
 
\end_layout

\begin_layout Standard
AES schränkt die Blocklänge auf 128 Bit ein.
 Die Schlüssellänge kann jedoch zwischen 128, 192 und 256 Bit gewählt werden,
 weshalb zwischen den drei AES-Varianten AES-128, AES-192 und AES-256 unterschie
den wird.
 AES bietet ein sehr hohes Maß an Sicherheit und ist in den USA sogar für
 staatliche Dokumente mit höchster Geheimhaltungsstufe zugelassen.
 Der Algorithmus ist frei verfügbar und darf ohne Lizenzgebühren eingesetzt
 sowie in Software bzw.
 Hardware implementiert werden.
\end_layout

\begin_layout Subsubsection
CUDA Framework
\end_layout

\begin_layout Standard
Das „Compute Unified Device Architecture Software Developer Kit“ (CUDA SDK)
 wurde von NVIDA am 15.
 Februar 2007 erstmals der Öffentlichkeit vorgestellt.
 Intention dieses SDKs ist, die Programmierung aktueller Grafikkarten unter
 einer einheitlichen und standardisierten Schnittstelle zu ermöglichen.
\end_layout

\begin_layout Standard
Die Architektur moderner GPUs ist aufgrund ihrer Geschichte als reine Berechnung
seinheit für Bildschirmausgaben für den Zweck ausgelegt, Operationen parallel
 auszuführen.
 Als Co-Prozessor können GPUs somit Dank der CUDA-API dazu genutzt werden,
 bestimmte Programmteile signifikat schneller abzuarbeiten.
\end_layout

\begin_layout Standard
CUDA basiert auf einer optimierten Variante von C (
\begin_inset Quotes eld
\end_inset

C for CUDA
\begin_inset Quotes erd
\end_inset

) und ist damit weitestgehend plattformunabhängig.
 So ist es möglich, entsprechend programmierte CUDA-Anwendungen unter Windows,
 Linux und Mac OS auszuführen - eine kompatible Grafikkarte vorausgesetzt.
\end_layout

\begin_layout Section
GPU Architektur
\end_layout

\begin_layout Standard
Zum besseren Verständnis der AES-Implementierung, ist ein Überblick über
 die Speicher- und Prozessverwaltungsarchitektur von Nöten.
 Die nachfolgenden Erläuterung beziehen sich zwar speziell auf die verwendete
 Grafikkarte, sind jedoch in großen Teilen auf verwandte Modelle übertragbar.
 Hierbei ist besonders zu beachten, dass die Anzahl der Multiprozessoren
 auf der GPU, sowie die Anzahl der Streaming-Prozessoren (SP) je nach Modell
 unterschiedlich sind.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/GPU-Architecture.png
	width 16.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:GPU-Architecture-Overview"

\end_inset

GPU-Architektur
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Prozessverwaltung
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/GPU-Architecture_Grid_and_Blocks.png
	width 16.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Streaming Processor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Multithreaded Instruction Unit (MT IU)
\end_layout

\begin_layout Standard
Die MT IU verwaltet die Ausführung von Threads auf dem Multiprocessor.
 Hierbei werden einzelne Threads zu einem Block, mehrere Blöcke zu einem
 Grid zusammengefasst.
\end_layout

\begin_layout Subsubsection
Streaming Multiprocessor
\end_layout

\begin_layout Standard
Auf jeden Streaming Multiprocessor wird genau ein Block abgebildet.
 Die in dem Block befindlichen Threads werden -soweit möglich- parallel
 abgearbeitet.
 Hierbei hat jeder Thread in dem Block eine eindeutige ID, auf welche auch
 in dem Thread zugegriffen werden kann.
\end_layout

\begin_layout Subsubsection
Streaming Processor (SP)
\end_layout

\begin_layout Standard
Jeder SP führt genau einen Tread aus.
\end_layout

\begin_layout Subsection
Speicherhierarchie 
\begin_inset Note Note
status open

\begin_layout Plain Layout
UNBEDINGT auf Richtigkeit ueberpruefen!! GRAFIK FEHLT!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Moderne Grafikarten sind über die PCI-E Schnittstelle an die CPU angebunden.
 Über diesen Bus werden die Daten und Prozesse an die berechnenden Einheiten
 der GPU übertragen.
\end_layout

\begin_layout Subsubsection
Global Memory 
\end_layout

\begin_layout Standard
Der Global Memory (RAM) ist der Größte Bereich und sowohl von CPU als auch
 von der GPU schreib- und lesbar.
 Dieser Speicher ermöglicht den Austausch von Daten zwischen GPU und CPU.
 Dieser Speicher hat die größte Kapazität, ist jedoch der langsamste der
 Speicherhierarchie bezüglich der GPU.
 
\end_layout

\begin_layout Subsubsection
Constant Memory
\end_layout

\begin_layout Standard
Der Constant Memory ist physikalisch auf 64KB beschränkt.
\end_layout

\begin_layout Subsubsection
Register
\end_layout

\begin_layout Standard
Threads eines Bocks teilen sich gemeinsame Register.
\end_layout

\begin_layout Subsubsection*
Shared Memory
\end_layout

\begin_layout Standard
Für jeden Streaming-Multiprozessor-Prozessor ist ein Shared Memory vorgesehen,
 welches der schnellste -mit 16 KB jedoch auch der kleinste- Speicher in
 der Hierarchie der GPU ist.
 Der Multiprozessor teilt diesen verfügbaren Speicher und seinen Streamingprozes
soren auf.
 Dieser Speicher kann nur von der GPU gelesen und geschrieben werden.
 
\end_layout

\begin_layout Section
AES-Implementierung
\end_layout

\begin_layout Subsection
Algorithmus im Detail
\end_layout

\begin_layout Standard
Im diesem Kapitel wird der Ablauf des AES Algorithmus vorgestellt.
 Er besteht aus mehreren Phasen, auf die im Folgenden genauer eingegangen
 wird.
 Anzumerken sei, dass bei Beispielen der Einfachheit halber von einer 128
 Bit-Verschlüsselung ausgegangen wird.
\end_layout

\begin_layout Standard
Jeder Block wird zunächst in eine zweidimensionale Tabelle mit vier Zeilen
 und vier Spalten geschrieben, deren Zellen ein Byte groß sind.
 Jeder Block wird nun nacheinander bestimmten Transformationen unterzogen.
 Anstatt jeden Block einmal mit dem Schlüssel zu verschlüsseln, wendet AES
 verschiedene Teile des erweiterten Originalschlüssels nacheinander auf
 den Klartext-Block an.
 Die Anzahl r dieser Runden variiert und ist von der Schlüssellänge k abhängig:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Schlüssellänge k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runden r
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Rundenlängen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Ablauf jeder einzelnen Block-Verschlüsselung entspricht folgendem Schema:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/EncryptionProcess.eps
	height 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablaufschema
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Schlüsselexpansion
\end_layout

\begin_layout Standard
Vor der ersten Chiffrierung muss zunächst einmal der Schlüssel entsprechend
 aufbereitet werden.
\end_layout

\begin_layout Standard
Der Benutzerschlüssel muss in r+1 Teilschlüssel aufgeteilt werden, die sogenannt
en Rundenschlüssel.
 Diese müssen dieselbe Länge wie die Blöcke haben, was bedeutet, dass der
 Benutzerschlüssel zunächst auf die Länge k*(r+1) expandiert werden muss.
 Aus diesem werden die Rundenschlüssel erzeugt und ebenfalls in Tabellen
 (Arrays) mit vier Spalten und vier Zeilen gespeichert.
 Für die Erzeugung der ersten Spalte des jeweils nächsten Rundenschlüssels
 wird zunächst die letzte Spalte des vorherigen Schlüssels, am Anfang also
 des Benutzerschlüssels, genommen und um eine Zeile nach oben rotiert.
 Die oberste Zelle wird unten wieder eingefügt.
 Nun erfolgt eine Substitution der vier Werte mit Hilfe der sogenannten
 Substitutionsbox.
 Sie ist meist als Array aufgebaut und gibt an, wie jedes Byte durch einen
 anderen Wert zu ersetzen ist.
 
\end_layout

\begin_layout Standard
Die Konstruktion der S-Box unterliegt Designkriterien, die die Anfälligkeit
 für die Methoden der linearen und der differentiellen Kryptoanalyse sowie
 für algebraische Attacken minimieren sollen.
 Mit Hilfe der S-Box wird jedes Byte des Blocks durch ein Äquivalent ersetzt
 und die Daten somit monoalphabetisch verschlüsselt.
 Diese neuerzeugte Spalte wird mit der drei Spalten zurückliegenden Spalte
 und mit der ersten Spalte der sogenannten Rcon-Tabelle XOR-verknüpft.
 
\end_layout

\begin_layout Standard
Die Rcon-Tabelle ist ebenfalls in Form eines Arrays mit 4 Zeilen und einer
 Spalte für jeden Rundenschlüssel aufgebaut.
 Sie enthält konstante Werte die auf einem mathematischen System beruhen.
 Die aus der XOR-Verknüpfung erzeugten Werte ergeben die erste Spalte des
 nächsten Rundenschlüssels.
 Die restlichen drei Spalten ergeben sich jeweils aus einer XOR-Verknüpfung
 der davor liegenden und der zu dieser drei zurückliegenden Spalte.
 Für alle folgenden Rundenschlüssel läuft die Berechnung analog ab.
 Abbildung 3 veranschaulicht dieses Vorgehen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Berechnung der Rundenschlüssel
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Vorrunde
\end_layout

\begin_layout Standard
Bei AddRoundKey erfolgt eine XOR-Verknüpfung zwischen dem zu verschlüsselnden
 Block und dem ersten Rundenschlüssel (siehe Abb.4).
 Nur an dieser Stelle ist der Algorithmus vom Benutzerschlüssel abhängig.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/addroundkey.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AddRoundKey
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verschlüsselungsrunden
\end_layout

\begin_layout Standard
In den folgenden Verschlüsselungsrunden wird zunächst eine Substitution
 mittels der erwähnten S-Box durchgeführt.
 
\end_layout

\begin_layout Standard
Im darauffolgenden Schritt, genannt ShiftRow, werden die Zeilen um eine
 bestimmte Anzahl von Spalten nach links verschoben und links hinausgeschobene
 Zellen rechts wieder angefügt.
 Die erste Zeile bleibt konstant, die zweite wird um eine, die dritte um
 zwei und die vierte um drei Spalten verschoben.
 Abbildung 5 veranschaulicht dieses Vorgehen.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/shiftrow.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ShiftRow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im MixColumn-Schritt wird zunächst jede Zelle mit einer Konstanten multipliziert
 und dann die Spalten mit den Ergebnissen der Multiplikation XOR verknüpft.
 Durch eine geschickte Analyse dieser Operation, vereinfacht sich die Rechnung
 zu einer simplen Matrizenmultiplikation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/mixcolumn.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MixColumn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum Ende jeder Verschlüsselungsrunde wird noch einmal AddRoundKey ausgeführt.
 Abgeschlossen wird die Verschlüsselung mit der Schlussrunde, sie verläuft
 identisch zu den übrigen Verschlüsselungsrunden mit dem Unterschied, dass
 keine MixColumn-Funktion ausgeführt wird.
\end_layout

\begin_layout Subsubsection
Entschlüsselung
\end_layout

\begin_layout Standard
Bei der Entschlüsselung von Daten wird entsprechend rückwärts vorgegangen.
 Die Daten werden zunächst wieder in zweidimensionale Tabellen gelesen und
 die Rundenschlüssel generiert.
 Allerdings wird nun mit der Schlussrunde angefangen und alle Funktionen
 in jeder Runde in der umgekehrten Reihenfolge aufgerufen.
 Durch die vielen (symmetrischen) XOR-Verknüpfungen unterscheiden sich die
 meisten Funktionen zum Entschlüsseln nicht von denen zum Verschlüsseln.
 Jedoch muss eine andere S-Box genutzt werden (die sich aus der originalen
 S-Box berechnen lässt) und die Zeilenverschiebungen erfolgen in die andere
 Richtung.
\end_layout

\begin_layout Subsection
C++ Implementierung
\end_layout

\begin_layout Standard
Ausgangspunkt der weiteren Bearbeitung ist eine unfertige C++ Implementierung
 des Algorithmus von Paulo S.
 L.
 M.
 Barreto
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verweis!!!
\end_layout

\end_inset

.
 Der Autor hat bereits erste Ansätze zur Datenverschlüsselung auf einer
 GPU programmiert, hat das Projekt jedoch aus unbekannten Gründen eingestellt,
 sodass noch einige Ergänzungen und Änderungen vorgenommen werden müssen.
\end_layout

\begin_layout Standard
Die Implementierung ist Dank der Ausnutzung komplexerer Galois-Feld-Operationen
 vergleichsweise schnell.
 Hierbei werden die Berechnungen durch Nutzung vorkalkulierter Tabellen
 auf Kosten der Speichereffizienz beschleunigt.
 Der Aufwand der Verschlüsselung verringert sich somit auf eine Reihe (schneller
) Binäroperationen, welche sich auf der GPU vorteilhaft parallel ausführen
 lassen können.
\end_layout

\begin_layout Standard
Zusätzlich ist anzumerken, dass zugunsten der Parallelität der sogenannte
 
\begin_inset Quotes eld
\end_inset

Electronic Code Book Mode
\begin_inset Quotes erd
\end_inset

 (ECB) verwendet wird, also jeder Block mit dem gleichen expandierten Schlüssel
 chiffriert wird.
\end_layout

\begin_layout Subsubsection
Schnittstelle zur Außenwelt
\end_layout

\begin_layout Standard
Um von außen auf die Verschlüsselungsfunktionen zugreifen zu können, enthält
 die genutzte AES-Klasse neben dem Konstruktur 
\begin_inset Quotes eld
\end_inset

öffentliche
\begin_inset Quotes erd
\end_inset

 Funktionen für die Schlüsselexpansionen sowie für die Ver- bzw.
 Entschlüsselung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/class.eps
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Klassendiagramm mit public Funktionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CUDA-spezifische Veränderungen
\end_layout

\begin_layout Subsubsection
Prozessaufteilung
\end_layout

\begin_layout Subsubsection
Speichernutzung
\end_layout

\begin_layout Section
Tests und Benchmarks
\end_layout

\begin_layout Subsection
Testumgebung
\end_layout

\begin_layout Subsection
Ergebnisse
\end_layout

\begin_layout Section
Ausblick
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
