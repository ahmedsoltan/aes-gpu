#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\language ngerman
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Einführung und Grundlagen
\end_layout

\begin_layout Subsection
Aufgabenstellung
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Grundlagen
\end_layout

\begin_layout Subsubsection
AES im Kurzüberblick
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ibi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da der Data Encryption Standard aufgrund seiner geringen Schlüsselgröße
 und der stark angestiegenen Rechenleistungen als zu schwach eingestuft
 worden war, musste ein neuer Verschlüsselungsstandard her.
 Diesbezüglich hat die US Regierung im Jahre 1997 ein Wettbewerb abgehalten
 zu dem sich viele Arbeitsgruppen angemeldet hatten und Ihre Lösungen präsentier
ten.
\end_layout

\begin_layout Standard
Die Algorithmen wurden auf folgende Kriterien hin untersucht:
\end_layout

\begin_layout Itemize
Sicherheit
\end_layout

\begin_layout Itemize
Implementierbarkeit
\end_layout

\begin_layout Itemize
Ressourcenverbrauch / Speicherbedarf
\end_layout

\begin_layout Itemize
Geschwindigkeit
\end_layout

\begin_layout Standard
Als Gewinner wurde eine leicht veränderte Version des Rijndael, nach den
 Entwicklern Joan Daemen und Vincent Rijmen benannt, ausgewählt.
\end_layout

\begin_layout Standard
Der Algorithmus sei mit den heute zur Verfügung stehenden Mitteln nicht
 zu knacken und erlaube dank seines einfachen Aufbaus eine sehr schnelle
 Implementierung in unterschiedlichen Programmiersprachen.
 Dank der Einfachheit sei es auch sehr effizient und biete eine gute bis
 sehr gute Performance auf verschiedenen Plattformen, wie einem 32Bit Prozessor,
 8Bit Mikrocontroller und auch eine Implementierung in Hardware.
 Weiterhin benötigt der Algorithmus sehr wenig Ressourcen und ist damit
 ideal für die Anwendung in Umgebungen mit beschränkten Ressourcen, wie
 z.B.
 Chipkarten.
\end_layout

\begin_layout Standard
Der Rijndael ist ein Blockchiffre, d.h.
 der Algorithmus arbeitet mit einer fest vorgegebenen Bitgruppe arbeitet,
 einem sogenannten Block.
 Die gewöhnliche Größe eines Eingabeblocks beträgt 128Bit welcher in einen
 dazugehörigen Ausgabeblock gleicher Größe verschlüsselt wird.
 Dazu wird ein Schlüssel gebraucht.
 Bei Rijndael ist es theoretisch möglich einen Schlüssel beliebiger Größe
 zu nehmen, der AES jedoch nimmt nur die Schlüsselgrößen 128Bit, 192Bit
 und 256Bit an.
\end_layout

\begin_layout Standard
Rijndael verwendet zur Verschlüsselung eine umkehrbare 8x8Bit Matrix, genannt
 Substitution Box (kurz S-Box) und Berechnungen über einem Galoisekörper
 der Form GF[28].
 Diese Berechnungen erinnern an Fehlererkennende und –korrigierende Codes.
\end_layout

\begin_layout Standard
Um einen Block zu verschlüsseln, werden verschiedene Operationen nacheinander
 auf den Block angewendet, nämlich Substitutionen (S-Box) und Permutationen
 (P-Box).
 AES beruht damit auf ein Substitutions- und Permutations- Netzwerk (SPN).
 Der AES führt die genannten Operationen iterativ auf je einen Block aus.
 Ein Block muss sequenziell verarbeitet werden, aber es können mehrere Blöcke
 gleichzeitig verarbeitet werden, da diese unabhängig voneinander sind.
 Dieser Effekt ist ideal für die Nutzung des Algorithmus auf einer GPU,
 da diese sehr viele Operationen Parallel verarbeiten kann.
 Es können damit viele Blöcke Parallel verschlüsselt werden und dies führt
 zu einem theoretisch enormen Speedup.
\end_layout

\begin_layout Standard
Wie schon oben erwähnt ist eine Rijndael ein Blockchiffre, wobei die Blocklänge
 und die Schlüssellänge unabhängig voneinander variieren können.
 Es können die Werte 128 (min), 160, 192, 224 oder 256 Bits gewählt werden.
 Bei AES jedoch sind die Blockgrößen auf 128 Bit beschränkt, die Schlüsselgröße
 kann aber die Werte 128, 192 oder 256 Bit annehmen.
 Jeder Block wird im Rijndael in eine zweidimensionale Tabelle mit vier
 Zeilen geschrieben, wobei jede Zelle die Größe ein Byte hat.
 Die Anzahl der Spalten ist bei AES konstant und beträgt 4 (128Bit).
\end_layout

\begin_layout Subsubsection
CUDA Framework
\begin_inset Note Note
status open

\begin_layout Plain Layout
Krüger
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Standard Das „Compute Unified Device Architecture Software Developer Kit“
 (CUDA SDK) wurde von NVIDA am 15.
 Februar 2007 das erste mal der Öffentlichkeit vorgestellt.
 Ziel dieses SDKs ist es, eine parallele Ausführung von Code auf unterstützten
 Grafikkarten.
 Zur Zeit sind das die aktuellen Grafikkarten, welche mit einem GeForce,
 ION, Quadro oder Tesla Grafikprozessor ausgestattet sind.
 
\end_layout

\begin_layout Standard
Standard CUDA basiert auf eine abgewandelten Variante von C.
 Typischerweise wird bei CUDA Anwendungen die Busbandweite und Latenz zwischen
 CPU und GPU zum Engpass.
 Darüber hinaus erreicht man die optimale Geschwindigkeit nur, wenn man
 die Implementierung an die Hardware anpasst (z.B.
 sollte die Anzahl der parallellaufenden Threads gleich die Anzahl der Streaming
 -Prozessoren sein).
\end_layout

\begin_layout Standard
Standard CUDA ist weitestgehend plattformunabhängig.
 So ist es möglich, „CUDA-Programme“ auf Windows, Linux und Mac OSX auszuführen
 - eine kompatible Grafikkarte vorausgesetzt.
\end_layout

\begin_layout Section
GPU Architektur
\begin_inset Note Note
status open

\begin_layout Plain Layout
Krüger
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Historie
\end_layout

\begin_layout Standard
Ursprünglich war es die einzige Aufgabe einer Grafikkarte, ein Bild auf
 einem Anzeigegerät (wie z.B.
 einem Monitor) darzustellen.
 Im Laufe der Geschichte haben sie sich in programmierbare Prozessoren entwickel
t.
 Aufgrund ihrer Geschichte aus der Grafikberechnung, sind Grafikarten in
 der Lage, sehr viele Operationen parallel zu berechnen.
 Wie genau das von statten geht, wir im Kapitel der Architektur erwähnt.
 Durch Ausnutzen der Parallelität der Grafikkarte in Berechnungen kann gegenüber
 der Berechnung mit der CPU schneller berechnet werden.
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Subsubsection
Prozessoraufbau
\end_layout

\begin_layout Standard
Moderne Grafikarten sind über die PCI-E Schnittstelle an die CPU angebunden.
 Über diesen Bus werden die Daten und Prozesse an die berechnenden Einheiten
 der GPU übertragen.
\end_layout

\begin_layout Standard
Im Folgenden ist die Architektur der GPU abgebildet.
 Hierbei ist zu beachten, dass die Anzahl der Multiprozessoren auf der GPU,
 sowie die Anzahl der Streaming-Prozessoren (SP) je nach Modell unterschiedlich
 sind.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/GPU-Architecture.png
	width 16.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:GPU-Architecture-Overview"

\end_inset

GPU-Architecture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Multithreaded Instruction Unit (MT IU)
\end_layout

\begin_layout Standard
Die MT IU verwaltet die Ausführung von Threads auf dem Multiprocessor.
 Hierbei werden einzelne Threads zu einem Block, mehrere Blöcke zu einem
 Grid zusammengefasst.
\end_layout

\begin_layout Subsubsection
Streaming Multiprocessor
\end_layout

\begin_layout Standard
Auf jeden Streaming Multiprocessor wird genau ein Block abgebildet.
 Die in dem Block befindlichen Threads werden -soweit möglich- parallel
 abgearbeitet.
 Hierbei hat jeder Thread in dem Block eine eindeutige ID, auf welche auch
 in dem Thread zugegriffen werden kann.
\end_layout

\begin_layout Subsubsection
Streaming Processor (SP)
\end_layout

\begin_layout Standard
Jeder SP führt genau einen Tread aus.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/GPU-Architecture_Grid_and_Blocks.png
	width 16.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Streaming Processor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Speicherhierarchie 
\begin_inset Note Note
status open

\begin_layout Plain Layout
UNBEDINGT auf Richtigkeit ueberpruefen!!
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Global Memory 
\end_layout

\begin_layout Standard
Der Global Memory (RAM) ist der Größte Bereich und sowohl von CPU als auch
 von der GPU schreib- und lesbar.
 Dieser Speicher ermöglicht den Austausch von Daten zwischen GPU und CPU.
 Dieser Speicher hat die größte Kapazität, ist jedoch der langsamste der
 Speicherhierarchie bezüglich der GPU.
 
\end_layout

\begin_layout Subsubsection
Constant Memory
\end_layout

\begin_layout Standard
Der Constant Memory ist physikalisch auf 64KB beschränkt.
\end_layout

\begin_layout Subsubsection
Register
\end_layout

\begin_layout Standard
Threads eines Bocks teilen sich gemeinsame Register.
\end_layout

\begin_layout Subsubsection*
Shared Memory
\end_layout

\begin_layout Standard
Für jeden Streaming-Multiprozessor-Prozessor ist ein Shared Memory vorgesehen,
 welches der schnellste -mit 16 KB jedoch auch der kleinste- Speicher in
 der Hierarchie der GPU ist.
 Der Multiprozessor teilt diesen verfügbaren Speicher und seinen Streamingprozes
soren auf.
 Dieser Speicher kann nur von der GPU gelesen und geschrieben werden.
 
\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Funktionen im Detail
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ibi
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Galois-Feld-Theorie etc.
\end_layout

\begin_layout Subsubsection
MixColumn-Funktion
\end_layout

\begin_layout Subsubsection
Substitutionsbox
\end_layout

\begin_layout Subsubsection
ShiftRow-Funktion
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ibi
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CUDA-spezifische Veränderungen
\begin_inset Note Note
status open

\begin_layout Plain Layout
Simon
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Prozessaufteilung
\end_layout

\begin_layout Subsubsection
Speichernutzung
\end_layout

\begin_layout Section
Tests und Benchmarks
\begin_inset Note Note
status open

\begin_layout Plain Layout
Vermutlich Simon
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testumgebung
\end_layout

\begin_layout Subsection
Ergebnisse
\end_layout

\begin_layout Section
Ausblick
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
