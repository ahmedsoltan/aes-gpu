#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\language ngerman
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Beschleunigung von AES-Verschlüsselungen unter Zuhilfenahme einer GPU
\end_layout

\begin_layout Author
Simon Waloschek, Benedikt Krüger, Ibrahim Alptekin, Daniel Nickchen
\end_layout

\begin_layout Subject
Projektarbeit des Studienganges 
\begin_inset Quotes eld
\end_inset

Ingenieurinformatik
\begin_inset Quotes erd
\end_inset

 im Rahmen des Softwarepraktikums
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einführung und Grundlagen
\end_layout

\begin_layout Subsection
Einleitung
\end_layout

\begin_layout Standard
Moderne Verschlüsselungsalgorithmen sind im Allgemeinen sehr rechenintensiv
 und werden oft als Bestandteil des Betriebssystems ausgeführt.
 Da gewöhnliche CPUs für diese Art von Operationen nicht ausgelegt sind,
 wird das gesamte System durch die entstehende Auslastung gebremst.
 Es liegt also nahe, eine geeignetere Plattform für die Berechnung von Verschlüs
selungen zu nutzen.
\end_layout

\begin_layout Standard
Im Rahmen dieses Praktikums wird daher evaluiert, inwiefern sich moderne
 Grafikkarten bzw.
 FPGAs zur optimierteren Ausführung nutzen lassen.
 Die Verschlüsselungen sollen transparent in den Linux-Kernel eingebunden
 und systemweit zur Verfügung gestellt werden.
\end_layout

\begin_layout Standard
Im Folgenden wird mithilfe des CUDA-Frameworks von NVIDIA der AES-Algorithmus
 auf einer GPU vom Typ 
\begin_inset Quotes eld
\end_inset

8800 GTS
\begin_inset Quotes erd
\end_inset

 aus dem Hause NVIDIA implementiert und durch eine Reihe von Tests auf eine
 eventuelle Verbesserung der Datendurchsatzrate hin überprüft.
\end_layout

\begin_layout Subsection
Grundlagen
\end_layout

\begin_layout Subsubsection
AES im Kurzüberblick
\end_layout

\begin_layout Standard
Der Advanced Encryption Standard (AES) ist ein symmetrisches Kryptosystem.
 Es wurde von Joan Daemen und Vincent Rijmen im Rahmen eines international
 ausgeschriebenen Wettbewerbes des National Institute of Standards and Technolog
y (NIST) entwickelt.
 Als Nachfolger von DES und 3DES, gilt AES seit 2000 als De-facto Verschlüsselun
gsstandard, welcher Dank seiner starken Verschlüsselung selbst höchsten
 Sicherheitsansprüchen genügt.
\end_layout

\begin_layout Standard
Bei AES handelt es sich um ein Blockverschlüsselungssystem, auch Blockchiffre
 genannt, also ein Verschlüsselungsverfahren, bei dem der Klartext in eine
 Folge gleichgroßer Blöcke zerlegt wird.
 Diese Blöcke werden anschließend unabhängig voneinander mit einem aus einem
 Schlüsselwort berechneten Blockschlüssel chiffriert.
 Somit werden auch Chiffretextblöcke mit einer festen Länge erzeugt und
 letzendlich zum endgültigen Chiffretext aneinandergereiht.
 
\end_layout

\begin_layout Standard
AES schränkt die Blocklänge auf 128 Bit ein.
 Die Schlüssellänge kann jedoch zwischen 128, 192 und 256 Bit gewählt werden,
 weshalb zwischen den drei AES-Varianten AES-128, AES-192 und AES-256 unterschie
den wird.
 AES bietet ein sehr hohes Maß an Sicherheit und ist in den USA sogar für
 staatliche Dokumente mit höchster Geheimhaltungsstufe zugelassen.
 Der Algorithmus ist frei verfügbar und darf ohne Lizenzgebühren eingesetzt
 sowie in Software bzw.
 Hardware implementiert werden.
\end_layout

\begin_layout Subsubsection
CUDA Framework
\end_layout

\begin_layout Standard
Das „Compute Unified Device Architecture Software Developer Kit“ (CUDA SDK)
 wurde von NVIDA am 15.
 Februar 2007 erstmals der Öffentlichkeit vorgestellt.
 Intention dieses SDKs ist, die Programmierung aktueller Grafikkarten unter
 einer einheitlichen und standardisierten Schnittstelle zu ermöglichen.
\end_layout

\begin_layout Standard
Die Architektur moderner GPUs ist aufgrund ihrer Geschichte als reine Berechnung
seinheit für Bildschirmausgaben für den Zweck ausgelegt, Operationen parallel
 auszuführen.
 Als Co-Prozessor können GPUs somit Dank der CUDA-API dazu genutzt werden,
 bestimmte Programmteile signifikat schneller abzuarbeiten.
\end_layout

\begin_layout Standard
CUDA basiert auf einer optimierten Variante von C (
\begin_inset Quotes eld
\end_inset

C for CUDA
\begin_inset Quotes erd
\end_inset

) und ist damit weitestgehend plattformunabhängig.
 So ist es möglich, entsprechend programmierte CUDA-Anwendungen unter Windows,
 Linux und Mac OS auszuführen - eine kompatible Grafikkarte vorausgesetzt.
\end_layout

\begin_layout Section
GPU Architektur
\end_layout

\begin_layout Standard
Moderne Grafikkarten bestehen aus einer speziellen Architektur, welche es
 erlaubt, viele Rechenoperationen parallel auszuführen.
 Je nach Grafikkarte und Hersteller ist die Architektur jedoch verschieden.
 Im Folgenden wird auf die Architektur der „GeForce 8800 GTS“ von NVIDIA
 eingegangen, da diese verwendet wurde.
\end_layout

\begin_layout Subsection
Begriffsklärung
\end_layout

\begin_layout Standard
Um den Aufbau der Architektur und des Programmes besser verstehen zu können,
 wird an dieser Stelle auf einige Begrifflichkeiten eingegangen.
\end_layout

\begin_layout Standard
So bald ein CUDA-Programmfluss angestoßen wird, wird ein sogenanntes Grid
 erstellt, welches mehrere Threads enthält, welche wiederum alle die gleiche
 Kernel-Funktion ausführen.
\end_layout

\begin_layout Standard
Unter einer 
\begin_inset Quotes eld
\end_inset

Kernel-Funktion
\begin_inset Quotes erd
\end_inset

 wird die Funktion verstanden, welche parallel auf der Grafikarte ausgeführt
 werden soll, in diesem Fall sind dies 
\shape italic
AES_decrypt
\shape default
 und 
\shape italic
AES_encrypt
\shape default
.
 Da alle Kernel-Funktionen den gleichen Code ausführen, benötigen sie feste
 und einzigartige Variablen, über die sich die Kernel-Funktionen identifizieren
 können - schließlich soll jede Kernel-Funktion etwas Anderes und ihr Zugewiesen
es berechnen.
\end_layout

\begin_layout Standard
Hierzu werden die Threads in einer zweistufigen Hierarchie angeordnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/Grid_Block.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Thread-Hierarchie
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf der untersten Stufe werden die Threads in Blöcken angeordnet.
 Die Variablen über welche sich die Threads identifizieren können sind blockId
 und threadId – Also die Nummer des Blockes und Position des Threads im
 Block.
 Diese werden zur Laufzeit des Threads von der CUDA-runtime angelegt.
 Die Threads eines Blockes werden ein einer dreidimensionalen Struktur angelegt.
 So besteht jede threadId aus 3 Koordinaten: x, y und z.
 Wie viele Threads in jeder Richtung angelegt werden, wird bei dem sogenannten
 „Kernen-Launch“ bestimmt, hierzu später mehr.
 Es können jedoch maximal 512 Threads einem Block zugewiesen werden.
 Wie sie in dem Block angelegt werden (z.B.
 512x1x1, 16x16x2 oder 8x16x2) ist dem Entwickler überlassen.
 Da die Threads in einer dreidimensionalen Struktur abgelegt werden, ist
 auch threadId eine Struktur, die diese 3 Koordinaten hält.
 Es kann also zum Beispiel die genaue Position des Threads abgefragt werden,
 indem 
\shape italic
threadId.x
\shape default
, 
\shape italic
threadId.y
\shape default
 und 
\shape italic
threadId.z
\shape default
 ausgewertet werden.
\end_layout

\begin_layout Standard
Auf der oberen Stufe der Hierarchie werden die Blöcke zu einem Grid zusammengefa
sst.
 werden die Blöcke (mit den darin abgelegten Threads) in einem zweidimensionalen
 Koordinatensystem abgelegt.
 Der Programmierer kann bei dem Aufruf der Kernel-Funktion in CUDA bestimmen,
 wie viele Blöcke in x- und y-Richtung angelegt werden sollen.
 Hierbei ist zu beachten, dass die Dimensionen des Grids einmalig angelegt
 werden - bei „Kernel-Launch“.
 Später kann hierauf kein Einfluss mehr genommen werden! Auch die blockId
 muss also eine zweidimensionale Struktur beinhalten: 
\shape italic
blockId.x
\shape default
 und 
\shape italic
blockId.y
\shape default
.
\end_layout

\begin_layout Subsection
Der Kernel-Launch
\end_layout

\begin_layout Standard
Der Kernel-Launch bestimmt, in welchen Dimensionen die Blöcke und das Grid
 angelegt werden sollen.
 Damit wird auch bestimmt, wie viele Threads insgesamt ausgeführt werden
 sollen.
\end_layout

\begin_layout Standard
Zunächst wird bestimmt, wie die Dimensionen der Blöcke aussehen sollen:
\shape italic

\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

dim3 dimBlock(2,2,2);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anschließend werden die Dimensionen des Grids festgelegt:
\shape italic

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

dim3 dimGrid(2,3,1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei den Dimensionen des Grids werden lediglich die x- und y-Dimensionen
 berücksichtigt, da die Grid-Struktur nur zweidimensional ist.
 So ist es üblich, als dritte Variable den Wert 1 zu setzen, es ist jedoch
 ein beliebiger Wert möglich!
\end_layout

\begin_layout Standard
Zum Schluss wird der eigentliche Kernel-Launch ausgeführt.
 Hierbei ist es möglich, den Threads eine Liste an Parametern zu übergeben:
\shape italic

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

KernelFunktion<<<dimGrid, dimBlock>>>( PARAMETERLISTE);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist jedoch zu beachten, dass alle Threads, welche mit diem Kernel-Launch
 angestossen werden, die selben Parameter bekommen.
\end_layout

\begin_layout Subsection
Die Architektur der GeForce 8800 GTS
\end_layout

\begin_layout Standard
Die Grafikkarte ist über einen Chipsatz mit der CPU verbunden.
 Hierbei hat der Chipsatz nur Zugriff auf den Global-Memory der Grafikkarte:
 Über diesen wird also mit dem Host kommuniziert.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/Physical_Memory_Layout.tif
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Speicherlayout
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die „GeForce 8800 GTS“ besteht aus 16 Multiprozessoren (MP).
 Jeder der MPs hat einen eigenen Speicher, den sog.
 „Shared Memory“ (16384 bytes pro MP), sowie eigene Register (8192 pro MP)
 und 8 Streamingprozessoren (SP).
 Die SPs führen jeweils genau einen Thread aus.
 Ist ein Thread beendet, so wird der Nächste gestartet.
 Diese Aufgabe übernimmt ein Scheduler.
\end_layout

\begin_layout Standard
Ist ein Block einem MP zugweisen, so werden jeweils 32 Threads aus dem Block
 zu einem 
\shape italic
Warp
\shape default
 zusammengefasst (wobei die Größe der Warps von der Hardware der Grafikkarte
 abhängt).
 In dem Warp werden die threadIds fortlaufend vergeben (der erste Warp von
 0 bis 31, der zweite von 32 bis 63...).
 Da bei der verwendeten Grafikkarte maximal 768 Threads einem MP zugeordnet
 werden können, kann jeder MP 768/32=24 Warps beherbergen.
\end_layout

\begin_layout Standard
Diese Mehrfachzuordnung wurde eingeführt, um hohe Latenzen bei Zugriffen
 auf den Speicher besser abfangen zu können.
 Wenn ein Befehl eines Threads aus einem Warp sehr lange auf das Ergebniss
 einer Speicher-Operation warten muss, so wird der Warp aus der Ausführung
 genommen und in eine Liste mit 
\begin_inset Quotes eld
\end_inset

wartenden Warps
\begin_inset Quotes erd
\end_inset

 eingegliedert.
 Dem SP der den Thread ausführte, wird ein Warp aus der Liste der 
\begin_inset Quotes eld
\end_inset

ausführungs-fertigen Warps
\begin_inset Quotes erd
\end_inset

 zugeordnet und gestartet.
 Das führt dazu, dass die SPs nahezu immer ausgelastet sind.
\end_layout

\begin_layout Subsection
Speicherhierarchie
\end_layout

\begin_layout Standard
Der Speicher, auf den sowohl Grafikkarte als auch CPU Zugriff haben, ist
 der 
\shape italic
(D)RAM
\shape default
 („Global Memory“).
 Dieser ist für gewöhnlich am größten und jedoch auch am langsamsten.
\end_layout

\begin_layout Standard
Von diesem Speicher werden die Daten im Verlauf des Programmes in den 
\shape italic
Shared Memory
\shape default
 geladen.
 Dieser befindet sich auf der Grafikkarte und ist auch nur von dieser anzusprech
en.
 Jeder MP hat die gleiche Größe des Shares Memory: 16 KB.
 Dieser wird auf die SPs des MPs aufgeteilt.
\end_layout

\begin_layout Standard
Zusätzlich gibt es noch einen Speicher für Konstanten des Programmes, den
 sog.

\shape italic
 Constant Memory
\shape default
.
 Dieser ist physikalisch auf 64 KB beschränkt und für alle SPs des MPs zugänglic
h! Für die Berechnungen hat jeder SP darüber hinaus 
\shape italic
Register
\shape default
, welche die schnellsten Zugriffszeiten aufweisen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/Speicherpyramiede.tif
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Speicherhierarchie Grafikkarte
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei der Speicherhierarchie ist zu beachten, dass die beiden wichtigsten
 Ebenen (DRAM und Global Memory) physikalisch getrennt liegen (Vgl.
 Abb.
 2).
 So liegt der RAM auf dem Mainboard und ist für CPU und Grafikkarte ansprechbar.
 Der Global Memory ist nur von der Grafikkarte ansprechbar.
 So sind die Ergebnisse der Berechnungen von dem Shared Memory explizit
 auf den RAM zu kopieren!
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/fneng-02-011-g002.jpg
	width 90text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
8800GTS-Architektur
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ein Thread wird in seinem Block ausgeführt.
 Hierbei kann der Thread sowohl auf seine 
\shape italic
Register
\shape default
 (vgl.
 Abb.
 4: 
\begin_inset Quotes eld
\end_inset

Private Memory
\begin_inset Quotes erd
\end_inset

), wie auch auf den Shared Memory zugreifen.
 Der Shared Memory dient hierbei zur Kommunikation der Threads untereinander;
 Alle Threads haben Lese- und Schreibzugriff auf ihn.
 Der Shared Memory ist hierbei nicht gecached, d.h.
 Veränderungen im Shared Memory werden direkt in den Hauptspeicher geschrieben.
 Der Datenaustausch zwischen CPU und Grafikkarte geschieht über den Global
 Memory.
 Dies wird explizit beim Programmieren angegeben, welche Daten an welche
 Position (unter welchem 
\begin_inset Quotes eld
\end_inset

Namen
\begin_inset Quotes erd
\end_inset

) auf die Grafikkarte kopiert werden sollen.
\end_layout

\begin_layout Standard
Im Folgenden wird ein kleines Beispiel zur Veranschaulichung benutzt:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},language={C++}"
inline false
status open

\begin_layout Plain Layout

float *a_h, *a_d, *b_h;
\end_layout

\begin_layout Plain Layout

nBytes = sizeof(float);
\end_layout

\begin_layout Plain Layout

a_h = (float*) malloc(nBytes);
\end_layout

\begin_layout Plain Layout

b_h = (float*) malloc(nBytes);
\end_layout

\begin_layout Plain Layout

cudaMalloc ((void**) &a_d, nBytes);
\end_layout

\begin_layout Plain Layout

cudaMemcpy(a_d, a_h, nBytes, cudaMemocpyHostToDevice);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cudaMemcpy(b_h, a_d, nBytes, cudaMemcpyDecviceToHost);
\end_layout

\begin_layout Plain Layout

free(a_h); 
\end_layout

\begin_layout Plain Layout

free(b_h);
\end_layout

\begin_layout Plain Layout

cudaFree(a_d);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hier werden zunächst 3 Variablen angelegt: 
\shape italic
a_h
\shape default
, 
\shape italic
b_h
\shape default
 (Host-Daten) sowie
\shape italic
 a_d
\shape default
 (Device-Daten).
 Hierzu wird der Platz im Speicher -sowohl auf dem Host als auch auf der
 Grafikkarte) reserviert.
 Der Befehl 
\shape italic
cudaMalloc
\shape default
 legt also einen 
\shape italic
nBytes
\shape default
 großen Platz im Speicher für die Variable 
\shape italic
a_d
\shape default
 an, in den dann mittels 
\shape italic
cudaMemcpy 
\shape default
die Werte von 
\shape italic
a_h
\shape default
 kopiert werden.
 Nach ggf.
 einiger Berechnung wird dann der Inhalt der Device-Variable 
\shape italic
a_d
\shape default
 zurück in die Host-Variable 
\shape italic
b_h
\shape default
 kopiert.
 Hierbei ist zu beachten, dass die Daten wirklich kopiert werden, es sollten
 also möglich wenig Daten ausgetauscht werden müssen, bzw.
 das Kopieren nicht doppelt erfolgen.
 Zum Schulss werden die Daten aus dem Host-Speicher und dem Device-Speicher
 gelöscht.
 Es fällt auf, dass die Syntax von CUDA an die C-Syntax angelehnt ist, was
 den Einstieg von C-Programmierern in CUDA wesentlich vereinfacht.
\end_layout

\begin_layout Subsection
Ausführung
\end_layout

\begin_layout Standard
Jeder MP bekommt einen Warp zugewiesen.
 Bei der verwendeten „GeForce 8800 GTS“ entspricht ein Warp einer Ansammlung
 von 32 Threads.
 Die Threads bestehen pro Ausführung in dem Warp immer aus dem gleichen
 Quellcode.
 Sie bekommen jedoch intern IDs zugewiesen, über welche sie sich identifizieren
 und - entsprechend ihrem Programmfluss - beeinflussen können.
 Der Thread wird gemeinsam mit den Eingabedaten auf die Grafikkarte kopiert,
 wobei die Eingabedaten in den Shared Memory abgelegt werden.
 Anschließend beginnen die SPs mit der Bearbeitung der Daten.
 Wenn alle Threads berechnet wurden - also im Normalfall jeder SP 2 Threads
 bearbeitet hat - werden die Ergebnisse aus dem Shared Memory zurück in
 den RAM kopiert und von dort über die CPU weiterverwendet.
 Im Anschluss ist der MP bereit für den nächsten Warp und das Ganze beginnt
 wieder von vorne.
 
\end_layout

\begin_layout Section
AES-Implementierung
\end_layout

\begin_layout Subsection
Algorithmus im Detail
\end_layout

\begin_layout Standard
Im diesem Kapitel wird der Ablauf des AES Algorithmus vorgestellt.
 Er besteht aus mehreren Phasen, auf die im Folgenden genauer eingegangen
 wird.
 Anzumerken sei, dass bei Beispielen der Einfachheit halber von einer 128
 Bit-Verschlüsselung ausgegangen wird.
\end_layout

\begin_layout Standard
Jeder Block wird zunächst in eine zweidimensionale Tabelle mit vier Zeilen
 und vier Spalten geschrieben, deren Zellen ein Byte groß sind.
 Jeder Block wird nun nacheinander bestimmten Transformationen unterzogen.
 Anstatt jeden Block einmal mit dem Schlüssel zu verschlüsseln, wendet AES
 verschiedene Teile des erweiterten Originalschlüssels nacheinander auf
 den Klartext-Block an.
 Die Anzahl r dieser Runden variiert und ist von der Schlüssellänge k abhängig:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Schlüssellänge k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runden r
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
192
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Rundenlängen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Ablauf jeder einzelnen Block-Verschlüsselung entspricht folgendem Schema:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/EncryptionProcess.eps
	height 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablaufschema
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Schlüsselexpansion
\end_layout

\begin_layout Standard
Vor der ersten Chiffrierung muss zunächst einmal der Schlüssel entsprechend
 aufbereitet werden.
\end_layout

\begin_layout Standard
Der Benutzerschlüssel muss in r+1 Teilschlüssel aufgeteilt werden, die sogenannt
en Rundenschlüssel.
 Diese müssen dieselbe Länge wie die Blöcke haben, was bedeutet, dass der
 Benutzerschlüssel zunächst auf die Länge k*(r+1) expandiert werden muss.
 Aus diesem werden die Rundenschlüssel erzeugt und ebenfalls in Tabellen
 (Arrays) mit vier Spalten und vier Zeilen gespeichert.
 Für die Erzeugung der ersten Spalte des jeweils nächsten Rundenschlüssels
 wird zunächst die letzte Spalte des vorherigen Schlüssels, am Anfang also
 des Benutzerschlüssels, genommen und um eine Zeile nach oben rotiert.
 Die oberste Zelle wird unten wieder eingefügt.
 Nun erfolgt eine Substitution der vier Werte mit Hilfe der sogenannten
 Substitutionsbox.
 Sie ist meist als Array aufgebaut und gibt an, wie jedes Byte durch einen
 anderen Wert zu ersetzen ist.
 
\end_layout

\begin_layout Standard
Die Konstruktion der S-Box unterliegt Designkriterien, die die Anfälligkeit
 für die Methoden der linearen und der differentiellen Kryptoanalyse sowie
 für algebraische Attacken minimieren sollen.
 Mit Hilfe der S-Box wird jedes Byte des Blocks durch ein Äquivalent ersetzt
 und die Daten somit monoalphabetisch verschlüsselt.
 Diese neuerzeugte Spalte wird mit der drei Spalten zurückliegenden Spalte
 und mit der ersten Spalte der sogenannten Rcon-Tabelle XOR-verknüpft.
 
\end_layout

\begin_layout Standard
Die Rcon-Tabelle ist ebenfalls in Form eines Arrays mit 4 Zeilen und einer
 Spalte für jeden Rundenschlüssel aufgebaut.
 Sie enthält konstante Werte, die auf einem mathematischen System beruhen.
 Die aus der XOR-Verknüpfung erzeugten Werte ergeben die erste Spalte des
 nächsten Rundenschlüssels.
 Die restlichen drei Spalten ergeben sich jeweils aus einer XOR-Verknüpfung
 der davor liegenden und der zu dieser drei zurückliegenden Spalte.
 Für alle folgenden Rundenschlüssel läuft die Berechnung analog ab.
\end_layout

\begin_layout Subsubsection
Vorrunde
\end_layout

\begin_layout Standard
Bei AddRoundKey erfolgt eine XOR-Verknüpfung zwischen dem zu verschlüsselnden
 Block und dem ersten Rundenschlüssel (siehe Abb.4).
 Nur an dieser Stelle ist der Algorithmus vom Benutzerschlüssel abhängig.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/addroundkey.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AddRoundKey
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Verschlüsselungsrunden
\end_layout

\begin_layout Standard
In den folgenden Verschlüsselungsrunden wird zunächst eine Substitution
 mittels der erwähnten S-Box durchgeführt.
 
\end_layout

\begin_layout Standard
Im darauffolgenden Schritt, genannt ShiftRow, werden die Zeilen um eine
 bestimmte Anzahl von Spalten nach links verschoben und links hinausgeschobene
 Zellen rechts wieder angefügt.
 Die erste Zeile bleibt konstant, die zweite wird um eine, die dritte um
 zwei und die vierte um drei Spalten verschoben.
 Abbildung 5 veranschaulicht dieses Vorgehen.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/shiftrow.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ShiftRow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im MixColumn-Schritt wird zunächst jede Zelle mit einer Konstanten multipliziert
 und dann die Spalten mit den Ergebnissen der Multiplikation XOR verknüpft.
 Durch eine geschickte Analyse dieser Operation, vereinfacht sich die Rechnung
 zu einer simplen Matrizenmultiplikation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/mixcolumn.eps
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MixColumn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum Ende jeder Verschlüsselungsrunde wird noch einmal AddRoundKey ausgeführt.
 Abgeschlossen wird die Verschlüsselung mit der Schlussrunde, sie verläuft
 identisch zu den übrigen Verschlüsselungsrunden mit dem Unterschied, dass
 keine MixColumn-Funktion ausgeführt wird.
\end_layout

\begin_layout Subsubsection
Entschlüsselung
\end_layout

\begin_layout Standard
Bei der Entschlüsselung von Daten wird entsprechend rückwärts vorgegangen.
 Die Daten werden zunächst wieder in zweidimensionale Tabellen gelesen und
 die Rundenschlüssel generiert.
 Allerdings wird nun mit der Schlussrunde angefangen und alle Funktionen
 in jeder Runde in der umgekehrten Reihenfolge aufgerufen.
 Durch die vielen (symmetrischen) XOR-Verknüpfungen unterscheiden sich die
 meisten Funktionen zum Entschlüsseln nicht von denen zum Verschlüsseln.
 Jedoch muss eine andere S-Box genutzt werden (die sich aus der originalen
 S-Box berechnen lässt) und die Zeilenverschiebungen erfolgen in die andere
 Richtung.
\end_layout

\begin_layout Subsection
C++ Implementierung
\end_layout

\begin_layout Standard
Ausgangspunkt der weiteren Bearbeitung ist eine unfertige C++ Implementierung
 des Algorithmus von Paulo S.
 L.
 M.
 Barreto
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verweis!!!
\end_layout

\end_inset

.
 Der Autor hat bereits erste Ansätze zur Datenverschlüsselung auf einer
 GPU programmiert, hat das Projekt jedoch aus unbekannten Gründen eingestellt,
 sodass noch einige Ergänzungen und Änderungen vorgenommen werden müssen.
\end_layout

\begin_layout Standard
Die Implementierung ist Dank der Ausnutzung komplexerer Galois-Feld-Operationen
 vergleichsweise schnell.
 Hierbei werden die Berechnungen durch Nutzung vorkalkulierter Tabellen
 auf Kosten der Speichereffizienz beschleunigt.
 Der Aufwand der Verschlüsselung verringert sich somit auf eine Reihe (schneller
) Binäroperationen, welche sich auf der GPU vorteilhaft parallel ausführen
 lassen können.
\end_layout

\begin_layout Standard
Zusätzlich ist anzumerken, dass zugunsten der Parallelität der sogenannte
 
\begin_inset Quotes eld
\end_inset

Electronic Code Book Mode
\begin_inset Quotes erd
\end_inset

 (ECB) verwendet wird, also jeder Block mit dem gleichen expandierten Schlüssel
 chiffriert wird.
\end_layout

\begin_layout Subsubsection
Schnittstelle zur Außenwelt
\end_layout

\begin_layout Standard
Um von außen auf die Verschlüsselungsfunktionen zugreifen zu können, enthält
 die genutzte AES-Klasse neben dem Konstruktur 
\begin_inset Quotes eld
\end_inset

öffentliche
\begin_inset Quotes erd
\end_inset

 Funktionen für die Schlüsselexpansionen sowie für die Ver- bzw.
 Entschlüsselung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/class.eps
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Klassendiagramm mit public Funktionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CUDA-spezifische Veränderungen
\end_layout

\begin_layout Subsubsection
Prozessaufteilung
\end_layout

\begin_layout Standard
Zur bestmöglichen Ausnutzung der parallelen Verarbeitungsmöglichkeiten der
 GPU, sollte die Arbeitslast auf möglichst viele Threads aufgeteilt werden.
 Zu diesem Zweck werden zur Laufzeit die (hardwarespezifischen) Eigenschaften
 der GPU ausgewertet und die Programmausführung auf die maximal mögliche
 Anzahl an Blöcken verteilt, in denen schließlich alle verfügbaren Threads
 genutzt werden.
 Im Quelltext wird dies auf folgende Weise gelöst:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void AES::encrypt(const uint *pt, uint *ct, uint n = 1) {
\end_layout

\begin_layout Plain Layout

	uint *cpt, *cct;
\end_layout

\begin_layout Plain Layout

	uint size = (n << 2)*sizeof(uint);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Speicherreservierung auf GPU
\end_layout

\begin_layout Plain Layout

	cudaMalloc((void**)&cpt, size);
\end_layout

\begin_layout Plain Layout

	cudaMalloc((void**)&cct, size); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Kopieren des Klartextes in den Global Memory der Grafikkarte
\end_layout

\begin_layout Plain Layout

	cudaMemcpy(cpt, pt, size, cudaMemcpyHostToDevice);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Ermitteln der architekturspezifischen Hardware
\end_layout

\begin_layout Plain Layout

	struct cudaDeviceProp prop;
\end_layout

\begin_layout Plain Layout

	cudaGetDeviceProperties(&prop, 0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Aufteilung der Berechnungen auf möglichst viele Threads
\end_layout

\begin_layout Plain Layout

	// Um Kompatibilitätsprobleme zu vermeiden, werden bei fehlender
\end_layout

\begin_layout Plain Layout

	// Parameterübergabe von n sinnvolle Defaultwerte genutzt.
\end_layout

\begin_layout Plain Layout

	uint blocks, threads = 1; 
\end_layout

\begin_layout Plain Layout

	if(n != 1) {
\end_layout

\begin_layout Plain Layout

		threads = (n < prop.maxThreadsPerBlock*2) ? n / 2 : prop.maxThreadsPerBlock;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	blocks = n / threads;
\end_layout

\begin_layout Plain Layout

	dim3 dimBlock(threads);
\end_layout

\begin_layout Plain Layout

	dim3 dimGrid(blocks);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// Erstellen des Kernel-Services sowie Start der Verschlüsselung
\end_layout

\begin_layout Plain Layout

	// Das Programm wartet an dieser Stelle auf die Rückgabe der
\end_layout

\begin_layout Plain Layout

	// Berechnungen.
\end_layout

\begin_layout Plain Layout

	AES_encrypt<<<dimGrid, dimBlock, size>>>(cpt, cct, ce_sched, Nr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Kopieren des Chiffrats in den Arbeitsspeicher
\end_layout

\begin_layout Plain Layout

	cudaMemcpy(ct, cct, size, cudaMemcpyDeviceToHost);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Speicherfreigabe
\end_layout

\begin_layout Plain Layout

	cudaFree(cpt);
\end_layout

\begin_layout Plain Layout

	cudaFree(cct);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Programm ermittelt also in den Zeilen 20 bis 25 die benötigten Parameter
 zur optimalen Aufteilung de Arbeitslast, erstellt Grids und Blöcke in entsprech
ender Dimensionierung und stößt den Kernel-Service für jeden einzelnen der
 Threads an.
\end_layout

\begin_layout Subsubsection
Speichernutzung
\end_layout

\begin_layout Standard
Neben dem obligatorischen Kopiervorgängen vom RAM des Host-PCs in den 
\shape italic
Global Memory
\shape default
 der Grafikkarte und zurück, werden die temporären Variablen in den für
 ihren jeweiligen Zweck laufzeiteffizientesten Speicherarten erstellt und
 verwendet.
 Da zur Verschlüsselung - wie bereits beschreiben - eine Vielzahl von vorberechn
eten Tabellen benutzt werden, werden diese Werte bei Aufruf des Klassenkonstrukt
ors in den schnellen 
\shape italic
Constant Memory
\shape default
 kopiert.
\end_layout

\begin_layout Standard
Der folgende Ausschnitt demonstriert den Speicherzugriff innerhalb der Kernel-Fu
nktion 
\shape italic
AES_encrypt
\shape default
 sowie (nebensächlich) die Adressierung des zu verschlüsselnden Textes im
 
\shape italic
Global Memory
\shape default
.
 
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},numbers=left"
inline false
status open

\begin_layout Plain Layout

__global__ void AES_encrypt(const uint *pt, uint *ct, uint *rek, uint Nr)
 {
\end_layout

\begin_layout Plain Layout

	// Berechnung des (threadabhängigen) Offsets zur Adressierung des Speichers
\end_layout

\begin_layout Plain Layout

	int x = blockIdx.x * blockDim.x + threadIdx.x;
\end_layout

\begin_layout Plain Layout

	int y = blockIdx.y * blockDim.y + threadIdx.y;
\end_layout

\begin_layout Plain Layout

	int i = x + y * gridDim.x * blockDim.x;
\end_layout

\begin_layout Plain Layout

	int offset = i << 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Deklarieren der temporären Variablen im Shared Memory
\end_layout

\begin_layout Plain Layout

	__shared__ __device__ uint s0, s1, s2, s3, t0, t1, t2, t3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Beginn der Verschlüsselung...
\end_layout

\begin_layout Plain Layout

	s0 = pt[offset + 0] ^ rek[0];
\end_layout

\begin_layout Plain Layout

	s1 = pt[offset + 1] ^ rek[1];
\end_layout

\begin_layout Plain Layout

	s2 = pt[offset + 2] ^ rek[2];
\end_layout

\begin_layout Plain Layout

	s3 = pt[offset + 3] ^ rek[3];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der threadspezifische Offset zur Speicheradressierung berechnet sich wie
 in Kapitel 2.1 beschrieben aus der 
\shape italic
blockId
\shape default
, der Blockgröße 
\shape italic
blockDim
\shape default
 und der 
\shape italic
threadId
\shape default
.
 Anschließend werden in Zeile 9 die temporären Variablen 
\shape italic
s0
\shape default
, 
\shape italic
s1
\shape default
 etc.
 im 
\shape italic
Shared Memory
\shape default
 angelegt.
 Dies erfordert zwar nach Abschluss der Verschlüsselung eine zusätzliche
 Kopieroperation zurück in den 
\shape italic
Global Memory
\shape default
, beschleunigt den Algorithmus aber dennoch aufgrund der schnelleren Zugriffsges
chwindigkeit auf die im weiteren Verlauf häufig genutzten Speicherstellen.
\end_layout

\begin_layout Section
Tests und Benchmarks
\end_layout

\begin_layout Subsection
Testumgebung
\end_layout

\begin_layout Standard
Zur Evaluierung der Korrektheit der entwickelten Lösung, werden zunächst
 vom NIST vorgegebene Klartext-Chiffre-Paare inklusive des passenden Schlüssels
 verwendet.
 Diese Paare umfassen verschiedene Verschlüsselungsstärken und Textlängen
 und eignen sich daher für einen aussagekräftigen Praxistest.
\end_layout

\begin_layout Standard
Um die Performance zu beurteilen und relevante Laufzeitanalysen durchzuführen,
 bietet NVIDIA als Teil des CUDA-SDKs den sogenannten 
\begin_inset Quotes eld
\end_inset

CUDA Profiler
\begin_inset Quotes erd
\end_inset

.
 Dieses grafische Tool erlaubt einen detaillierten Einblick in die Laufzeiten
 einzelner CUDA-Befehle und eignet sich somit zur Bewertung derer Geschwindigkei
t.
 Auch können damit eventuelle 
\begin_inset Quotes eld
\end_inset

Flaschenhälse
\begin_inset Quotes erd
\end_inset

 im Code aufgespürt und ggf.
 korrigiert werden.
\end_layout

\begin_layout Standard
Da die folgenden Tests möglichst unabhängig von der restlichen Hardware
 des Testcomputers sein sollten, wird unter Linux eine RAM-Disk mit verschieden
 großen (zufälligen) Binärdateien erstellt, um den Einfluss der Festplattenlese-
 und -schreibgeschwindigkeit zu minimieren.
 Diese Dateien werden dann unter Einbeziehung des CUDA Profilers vollständig
 ver- bzw.
 entschlüsselt.
\end_layout

\begin_layout Subsection
Ergebnisse
\end_layout

\begin_layout Section
Resumée
\begin_inset Note Note
status open

\begin_layout Plain Layout
?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
